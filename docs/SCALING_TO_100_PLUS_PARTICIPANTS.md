# План масштабирования голосовых каналов до 100+ участников

## Текущая архитектура (Mesh-топология)

### Проблемы текущей реализации:
- **Mesh-топология**: Каждый участник подключается напрямую к каждому другому участнику
- **Масштабирование**: При 100 участниках каждый должен поддерживать 99 WebRTC соединений
- **Ресурсы клиента**: 
  - CPU: ~99% при 100 участниках (обработка всех потоков)
  - Память: ~200-500 MB на клиенте
  - Пропускная способность: 100+ входящих аудио потоков
- **Ресурсы сервера**: Только signaling через WebSocket, медиа не проходит через сервер
- **Проблемы**:
  - Невозможно масштабировать выше 10-20 участников
  - Высокая нагрузка на клиентов
  - Проблемы с NAT traversal для множественных соединений
  - Сложность управления состоянием множественных пиров

## Целевая архитектура (SFU - Selective Forwarding Unit)

### Принцип работы:
- **Централизованный медиа-сервер**: Все участники подключаются к одному SFU серверу
- **Селективная пересылка**: SFU пересылает только активные аудио потоки
- **Масштабирование**: Каждый участник поддерживает только 1 исходящее и N входящих соединений (где N = количество активных спикеров)
- **Ресурсы клиента**:
  - CPU: ~5-10% (обработка только активных потоков)
  - Память: ~50-100 MB
  - Пропускная способность: 1 исходящий + до 10-20 входящих потоков

---

## Фаза 1: Подготовка и исследование (1-2 недели)

### 1.1 Исследование SFU решений
- [ ] **Оценка готовых решений**:
  - [ ] [Janus Gateway](https://janus.conf.meetecho.com/) - популярный, хорошо документированный
  - [ ] [Mediasoup](https://mediasoup.org/) - Node.js, гибкий, хорошая производительность
  - [ ] [Kurento](https://www.kurento.org/) - Java, более тяжелый
  - [ ] [Jitsi Videobridge](https://jitsi.org/jitsi-videobridge/) - Java, хорошо для больших групп
  - [ ] [LiveKit](https://livekit.io/) - коммерческий, но с open-source сервером
- [ ] **Критерии выбора**:
  - Поддержка WebRTC
  - Масштабируемость (100+ участников)
  - Простота интеграции
  - Производительность (CPU/память)
  - Поддержка селективной пересылки
  - Возможность кастомной логики

**Рекомендация**: **Mediasoup** - лучший баланс производительности, гибкости и простоты интеграции

### 1.2 Проектирование архитектуры
- [ ] **Схема развертывания**:
  ```
  Client <--WebRTC--> SFU Server <--WebRTC--> Client
                      (Mediasoup)
                      |
                      v
                  Signaling Server (FastAPI)
  ```
- [ ] **Компоненты**:
  - SFU сервер (отдельный процесс/контейнер)
  - Signaling сервер (текущий FastAPI)
  - Клиентская библиотека (обновленный VoiceClient)
- [ ] **Протоколы**:
  - WebRTC для медиа (через SFU)
  - WebSocket для signaling (текущий)
  - REST API для управления комнатами

### 1.3 Планирование миграции
- [ ] **Стратегия миграции**:
  - Поддержка обеих архитектур (mesh и SFU) с feature flag
  - Постепенный переход по комнатам
  - A/B тестирование
- [ ] **Обратная совместимость**:
  - Старые клиенты продолжают работать с mesh
  - Новые клиенты используют SFU
  - Автоматическое определение возможностей

---

## Фаза 2: Внедрение SFU сервера (2-3 недели)

### 2.1 Настройка Mediasoup сервера
- [ ] **Создание SFU сервиса**:
  - [ ] Новый Node.js сервис `sfu-server/`
  - [ ] Интеграция Mediasoup
  - [ ] Docker контейнер для SFU
- [ ] **Конфигурация**:
  - [ ] Настройка RTP портов (UDP)
  - [ ] Настройка ICE/STUN/TURN
  - [ ] Лимиты ресурсов (CPU, память)
  - [ ] Логирование и мониторинг
- [ ] **API для управления**:
  - [ ] REST API для создания/удаления комнат
  - [ ] WebSocket для signaling с клиентами
  - [ ] Интеграция с текущим signaling сервером

### 2.2 Интеграция с текущим бэкендом
- [ ] **Модификация VoiceSignalManager**:
  - [ ] Добавить поддержку SFU режима
  - [ ] Маршрутизация signaling сообщений
  - [ ] Управление комнатами в SFU
- [ ] **Новые endpoints**:
  - [ ] `POST /api/voice/rooms/{room_slug}/sfu/create` - создание комнаты в SFU
  - [ ] `DELETE /api/voice/rooms/{room_slug}/sfu` - удаление комнаты
  - [ ] `GET /api/voice/rooms/{room_slug}/sfu/status` - статус SFU комнаты
- [ ] **Feature flags**:
  - [ ] `USE_SFU_FOR_ROOM` - использовать SFU для конкретной комнаты
  - [ ] `SFU_ENABLED` - глобальный флаг включения SFU

### 2.3 Мониторинг и метрики
- [ ] **Метрики SFU**:
  - [ ] Количество активных комнат
  - [ ] Количество участников на комнату
  - [ ] Использование CPU/памяти SFU
  - [ ] Пропускная способность сети
  - [ ] Задержка обработки медиа
- [ ] **Интеграция с Prometheus**:
  - [ ] Экспорт метрик из SFU
  - [ ] Дашборды в Grafana

---

## Фаза 3: Обновление клиентской части (2-3 недели)

### 3.1 Новая архитектура VoiceClient
- [ ] **Рефакторинг VoiceClient.ts**:
  - [ ] Разделение на `MeshVoiceClient` и `SFUVoiceClient`
  - [ ] Общий интерфейс `IVoiceClient`
  - [ ] Фабрика для создания нужного типа клиента
- [ ] **SFUVoiceClient**:
  - [ ] Подключение к SFU через WebRTC
  - [ ] Управление одним исходящим потоком
  - [ ] Управление входящими потоками (только активные спикеры)
  - [ ] Автоматическое добавление/удаление потоков при изменении спикеров

### 3.2 Оптимизация воспроизведения
- [ ] **Селективное воспроизведение**:
  - [ ] Воспроизведение только активных спикеров (N самых громких)
  - [ ] Приоритизация спикеров по уровню звука
  - [ ] Динамическое добавление/удаление потоков
- [ ] **Адаптивное качество**:
  - [ ] Автоматическое снижение битрейта при высокой нагрузке
  - [ ] Приоритизация важных спикеров
- [ ] **Оптимизация памяти**:
  - [ ] Переиспользование AudioContext
  - [ ] Ограничение количества одновременных потоков (max 20-30)

### 3.3 Улучшение UI/UX
- [ ] **Индикаторы**:
  - [ ] Показ активных спикеров
  - [ ] Индикатор качества соединения
  - [ ] Статистика (количество участников, задержка)
- [ ] **Управление**:
  - [ ] Кнопка "Показать всех" для принудительного воспроизведения всех
  - [ ] Настройки качества звука
  - [ ] Фильтры шума (опционально)

---

## Фаза 4: Оптимизации для больших групп (1-2 недели)

### 4.1 Селективная пересылка
- [ ] **Логика на SFU**:
  - [ ] Определение активных спикеров (VAD - Voice Activity Detection)
  - [ ] Пересылка только N самых активных спикеров
  - [ ] Динамическое изменение N в зависимости от нагрузки
- [ ] **Приоритизация**:
  - [ ] Приоритет для спикеров с высоким уровнем звука
  - [ ] Приоритет для модераторов/админов
  - [ ] Равномерное распределение приоритетов

### 4.2 Адаптивное битрейт управление
- [ ] **На стороне клиента**:
  - [ ] Автоматическое снижение битрейта при проблемах сети
  - [ ] Мониторинг качества соединения
- [ ] **На стороне SFU**:
  - [ ] Адаптация битрейта в зависимости от нагрузки
  - [ ] Приоритизация важных потоков

### 4.3 Оптимизация signaling
- [ ] **Батчинг сообщений**:
  - [ ] Группировка signaling сообщений
  - [ ] Дебаунсинг обновлений состояния
- [ ] **Кэширование**:
  - [ ] Кэширование списка участников
  - [ ] Инкрементальные обновления

---

## Фаза 5: Тестирование и оптимизация (2 недели)

### 5.1 Нагрузочное тестирование
- [ ] **Сценарии**:
  - [ ] 10 участников (базовый тест)
  - [ ] 50 участников (средняя нагрузка)
  - [ ] 100 участников (целевая нагрузка)
  - [ ] 200+ участников (стресс-тест)
- [ ] **Метрики**:
  - [ ] CPU использование (клиент и сервер)
  - [ ] Память (клиент и сервер)
  - [ ] Пропускная способность сети
  - [ ] Задержка (latency)
  - [ ] Качество звука
  - [ ] Стабильность соединений

### 5.2 Оптимизация производительности
- [ ] **Профилирование**:
  - [ ] Анализ узких мест
  - [ ] Оптимизация горячих путей
- [ ] **Тюнинг**:
  - [ ] Настройка буферов
  - [ ] Оптимизация алгоритмов
  - [ ] Настройка параметров WebRTC

### 5.3 Тестирование совместимости
- [ ] **Браузеры**:
  - [ ] Chrome/Edge (Chromium)
  - [ ] Firefox
  - [ ] Safari (особое внимание - другие требования к WebRTC)
- [ ] **Сети**:
  - [ ] Различные типы NAT
  - [ ] Мобильные сети
  - [ ] WiFi с ограничениями

---

## Фаза 6: Развертывание и мониторинг (1 неделя)

### 6.1 Постепенное развертывание
- [ ] **Пилотное тестирование**:
  - [ ] Выбор тестовых комнат
  - [ ] Мониторинг метрик
  - [ ] Сбор обратной связи
- [ ] **Постепенный rollout**:
  - [ ] 10% комнат → 25% → 50% → 100%
  - [ ] Мониторинг на каждом этапе
  - [ ] Откат при проблемах

### 6.2 Мониторинг в продакшене
- [ ] **Дашборды**:
  - [ ] Количество активных комнат SFU
  - [ ] Среднее количество участников
  - [ ] Использование ресурсов
  - [ ] Ошибки и предупреждения
- [ ] **Алерты**:
  - [ ] Высокое использование CPU/памяти
  - [ ] Большое количество ошибок
  - [ ] Проблемы с соединениями

### 6.3 Документация
- [ ] **Техническая документация**:
  - [ ] Архитектура SFU
  - [ ] API документация
  - [ ] Руководство по развертыванию
- [ ] **Пользовательская документация**:
  - [ ] Руководство для администраторов
  - [ ] FAQ по голосовым каналам

---

## Технические детали реализации

### Выбранное решение: Mediasoup

**Преимущества**:
- Высокая производительность (C++ core, Node.js API)
- Гибкая архитектура
- Хорошая документация
- Активное сообщество
- Поддержка селективной пересылки
- Масштабируемость до тысяч участников

**Структура проекта**:
```
sfu-server/
├── src/
│   ├── server.ts          # Основной сервер
│   ├── room.ts            # Управление комнатами
│   ├── router.ts           # Медиа роутер
│   └── transport.ts       # WebRTC транспорты
├── package.json
└── Dockerfile
```

### Интеграция с текущим бэкендом

**Новый сервис**:
```python
# backend/app/services/sfu_manager.py
class SFUManager:
    async def create_room(room_slug: str) -> str:
        # Создать комнату в SFU через REST API
        pass
    
    async def delete_room(room_slug: str):
        # Удалить комнату
        pass
    
    async def get_room_status(room_slug: str) -> dict:
        # Получить статус комнаты
        pass
```

**Обновление VoiceSignalManager**:
```python
# Добавить поддержку SFU режима
if settings.use_sfu_for_room(room_slug):
    # Использовать SFU
    sfu_manager.create_room(room_slug)
else:
    # Использовать mesh (текущая логика)
    pass
```

### Клиентская часть

**Новый SFUVoiceClient**:
```typescript
class SFUVoiceClient implements IVoiceClient {
  private sfuConnection: RTCPeerConnection;
  private producers: Map<string, Producer>; // Исходящие потоки
  private consumers: Map<string, Consumer>; // Входящие потоки
  
  async connect(params: ConnectParams): Promise<void> {
    // Подключение к SFU
    // Создание producer для локального потока
    // Подписка на активных спикеров
  }
  
  private async subscribeToSpeaker(participantId: number): Promise<void> {
    // Подписка на поток спикера через SFU
  }
  
  private async unsubscribeFromSpeaker(participantId: number): Promise<void> {
    // Отписка от потока
  }
}
```

---

## Оценка ресурсов

### Серверные ресурсы (SFU)
- **CPU**: ~5-10% на 100 участников (1 ядро)
- **Память**: ~200-500 MB на комнату с 100 участниками
- **Сеть**: 
  - Входящая: ~100 * 50 kbps = 5 Mbps
  - Исходящая: ~100 * 50 kbps = 5 Mbps (для каждого участника)
  - Итого на комнату: ~500 Mbps (100 участников * 5 Mbps)

### Клиентские ресурсы
- **CPU**: ~5-10% (вместо 99% в mesh)
- **Память**: ~50-100 MB (вместо 200-500 MB)
- **Сеть**: 
  - Исходящая: ~50 kbps
  - Входящая: ~500 kbps - 1 Mbps (10-20 активных спикеров)

---

## Риски и митигация

### Риск 1: Сложность миграции
- **Митигация**: Постепенный переход, поддержка обеих архитектур

### Риск 2: Производительность SFU
- **Митигация**: Тщательное тестирование, мониторинг, возможность масштабирования

### Риск 3: Стоимость инфраструктуры
- **Митигация**: Оптимизация ресурсов, использование облачных решений

### Риск 4: Совместимость браузеров
- **Митигация**: Тестирование на всех основных браузерах, fallback на mesh

---

## Временная оценка

- **Фаза 1**: 1-2 недели
- **Фаза 2**: 2-3 недели
- **Фаза 3**: 2-3 недели
- **Фаза 4**: 1-2 недели
- **Фаза 5**: 2 недели
- **Фаза 6**: 1 неделя

**Итого**: 9-13 недель (2.5-3 месяца)

---

## Приоритеты

### Критичные (MVP):
1. Внедрение базового SFU сервера
2. Обновление клиента для работы с SFU
3. Базовая селективная пересылка (топ-10 спикеров)

### Важные:
4. Оптимизация производительности
5. Мониторинг и метрики
6. Тестирование на больших группах

### Желательные:
7. Адаптивное качество
8. Расширенные метрики
9. UI улучшения

---

## Следующие шаги

1. **Немедленно**: Изучить Mediasoup документацию и примеры
2. **На этой неделе**: Создать прототип SFU сервера
3. **В течение месяца**: Интегрировать SFU с текущим бэкендом
4. **В течение 2 месяцев**: Полная миграция клиентов

---

## Полезные ресурсы

- [Mediasoup Documentation](https://mediasoup.org/documentation/)
- [Mediasoup Examples](https://github.com/versatica/mediasoup-demo)
- [WebRTC Best Practices](https://webrtc.org/getting-started/testing)
- [Discord Engineering Blog](https://discord.com/tags/engineering) - статьи о масштабировании голосовых каналов

