<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <title>Charge Rooms Playground</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background: #f6f8fb;
        color: #1f2328;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        padding: 2rem 1.25rem 4rem;
      }

      main {
        max-width: 1120px;
        margin: 0 auto;
        display: grid;
        gap: 1.75rem;
      }

      .screen {
        display: grid;
        gap: 1.75rem;
      }

      header {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        padding-bottom: 1rem;
        border-bottom: 1px solid #d0d7de;
      }

      h1 {
        margin: 0;
        font-size: clamp(1.85rem, 2vw + 1.2rem, 2.4rem);
      }

      p {
        margin: 0;
        line-height: 1.5;
      }

      section {
        background: #fff;
        border-radius: 1rem;
        box-shadow: 0 18px 40px rgba(15, 23, 42, 0.08);
        padding: 1.75rem;
        display: grid;
        gap: 1.25rem;
      }

      section h2 {
        margin: 0;
        font-size: 1.25rem;
      }

      fieldset {
        border: 1px solid #d0d7de;
        border-radius: 0.75rem;
        padding: 1.25rem;
      }

      legend {
        font-weight: 600;
        padding: 0 0.5rem;
      }

      label {
        display: grid;
        gap: 0.35rem;
        font-size: 0.95rem;
      }

      input,
      select,
      textarea {
        font-family: inherit;
        font-size: 1rem;
        border-radius: 0.6rem;
        border: 1px solid #c1cad6;
        padding: 0.55rem 0.75rem;
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
      }

      textarea {
        resize: vertical;
        min-height: 80px;
      }

      input:focus,
      select:focus,
      textarea:focus {
        outline: none;
        border-color: #2563eb;
        box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2);
      }

      button {
        cursor: pointer;
        border-radius: 999px;
        border: none;
        background: linear-gradient(135deg, #2563eb, #6366f1);
        color: #fff;
        padding: 0.65rem 1.6rem;
        font-weight: 600;
        font-size: 1rem;
        transition: transform 0.1s ease, box-shadow 0.1s ease;
      }

      button:hover:not(:disabled) {
        transform: translateY(-1px);
        box-shadow: 0 14px 28px rgba(79, 70, 229, 0.22);
      }

      button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .inline {
        display: flex;
        gap: 0.75rem;
        flex-wrap: wrap;
        align-items: center;
      }

      .status {
        padding: 0.6rem 0.85rem;
        border-radius: 0.65rem;
        background: #f1f5f9;
        color: #0f172a;
        font-size: 0.9rem;
      }

      .status.error {
        background: #fee2e2;
        color: #7f1d1d;
      }

      .status.success {
        background: #dcfce7;
        color: #166534;
      }

      .grid-two {
        display: grid;
        gap: 1rem;
      }

      @media (min-width: 720px) {
        .grid-two {
          grid-template-columns: repeat(2, minmax(0, 1fr));
        }
      }

      ul.channels,
      ul.messages {
        list-style: none;
        padding: 0;
        margin: 0;
        display: grid;
        gap: 0.6rem;
      }

      ul.channels li {
        border: 1px solid #d0d7de;
        border-radius: 0.75rem;
        padding: 0.8rem 1rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: pointer;
        transition: border-color 0.2s ease, background 0.2s ease;
      }

      ul.channels li:hover {
        border-color: #6366f1;
        background: rgba(99, 102, 241, 0.08);
      }

      ul.channels li.active {
        border-color: #2563eb;
        background: rgba(37, 99, 235, 0.12);
      }

      .channel-info {
        display: grid;
        gap: 0.2rem;
      }

      .channel-letter {
        font-weight: 700;
        font-size: 0.85rem;
        color: #4338ca;
        text-transform: uppercase;
      }

      .channel-type {
        font-size: 0.85rem;
        color: #475569;
      }

      ul.messages {
        max-height: 280px;
        overflow-y: auto;
        padding-right: 0.5rem;
      }

      ul.messages li {
        background: #f8fafc;
        border-radius: 0.75rem;
        padding: 0.75rem 1rem;
        display: grid;
        gap: 0.35rem;
      }

      .message-meta {
        display: flex;
        gap: 0.6rem;
        align-items: baseline;
        font-size: 0.85rem;
        color: #475569;
      }

      .message-meta span {
        white-space: nowrap;
      }

      .message-content {
        white-space: pre-wrap;
        word-break: break-word;
        font-size: 0.95rem;
      }

      .chat-actions {
        display: grid;
        gap: 0.75rem;
      }

      .chat-actions textarea {
        min-height: 60px;
      }

      .voice-controls {
        display: grid;
        gap: 0.75rem;
      }

      audio {
        width: 100%;
      }

      .pill {
        border-radius: 999px;
        background: rgba(15, 23, 42, 0.06);
        padding: 0.15rem 0.6rem;
        font-size: 0.78rem;
        font-weight: 600;
        letter-spacing: 0.02em;
        text-transform: uppercase;
      }

      .hint {
        font-size: 0.85rem;
        color: #475569;
      }
    </style>
  </head>
  <body>
    <main>
      <header>
        <h1>Charge Playground</h1>
        <p>
          Минимальный клиент для проверки API: регистрация/логин, выбор комнаты по
          <code>slug</code>, текстовые и голосовые каналы. Требуется запущенный backend Charge.
        </p>
      </header>

      <div class="screen" id="screen-auth">
        <section aria-labelledby="settings-heading">
          <div class="inline" style="justify-content: space-between; align-items: flex-start; flex-wrap: wrap; gap: 1rem;">
            <div>
              <h2 id="settings-heading">Настройки подключения</h2>
              <p class="hint">По умолчанию используется <code>http://localhost:8000</code>. Можно переопределить.</p>
            </div>
            <div class="status" id="auth-status">Не авторизовано</div>
          </div>
          <form id="api-form" class="inline" style="gap: 0.75rem; flex-wrap: wrap;">
            <label style="flex: 1 1 260px;">
              Базовый URL API
              <input type="url" id="api-base" placeholder="http://localhost:8000" required />
            </label>
            <button type="submit">Сохранить</button>
          </form>
        </section>

        <section aria-labelledby="auth-heading">
          <h2 id="auth-heading">Регистрация и вход</h2>
          <div class="grid-two">
            <form id="register-form">
              <fieldset>
                <legend>Регистрация</legend>
                <label>
                  Логин
                  <input name="login" autocomplete="username" required />
                </label>
                <label>
                  Отображаемое имя
                  <input name="display_name" autocomplete="name" required />
                </label>
                <label>
                  Пароль
                  <input type="password" name="password" autocomplete="new-password" required />
                </label>
                <button type="submit">Создать аккаунт</button>
                <p class="status" id="register-status" hidden></p>
              </fieldset>
            </form>
            <form id="login-form">
              <fieldset>
                <legend>Вход</legend>
                <label>
                  Логин
                  <input name="login" autocomplete="username" required />
                </label>
                <label>
                  Пароль
                  <input type="password" name="password" autocomplete="current-password" required />
                </label>
                <button type="submit">Войти</button>
                <p class="status" id="login-status" hidden></p>
              </fieldset>
            </form>
          </div>
        </section>
      </div>

      <div class="screen" id="screen-workspace" hidden>
        <section aria-labelledby="workspace-heading">
          <div class="inline" style="justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem;">
            <div>
              <h2 id="workspace-heading">Создание каналов</h2>
              <p class="hint">Выберите комнату и создайте текстовый или голосовой канал.</p>
            </div>
            <button type="button" id="logout-button" style="background: #f8fafc; color: #1f2937; border: 1px solid #d0d7de;">Выйти</button>
          </div>
        </section>

        <section aria-labelledby="rooms-heading">
          <h2 id="rooms-heading">Комнаты и каналы</h2>
          <form id="room-form" class="inline">
            <label style="flex: 1 1 220px;">
              Slug комнаты
              <input name="slug" id="room-slug" placeholder="например, general" required />
          </label>
          <button type="submit">Загрузить</button>
          <button type="button" id="clear-room" style="background: #f8fafc; color: #1f2937; border: 1px solid #d0d7de;">Сбросить</button>
        </form>
        <div id="room-summary" class="status" hidden></div>
        <div id="channel-manage" hidden>
          <form
            id="channel-create-form"
            class="inline"
            style="gap: 0.75rem; flex-wrap: wrap; align-items: flex-end;"
          >
            <label style="flex: 1 1 260px;">
              Название канала
              <input name="name" id="channel-name" placeholder="Например, Общий" required />
            </label>
            <label style="flex: 0 1 180px;">
              Тип
              <select name="type" id="channel-type">
                <option value="text">Текстовый</option>
                <option value="voice">Голосовой</option>
              </select>
            </label>
            <button type="submit" id="channel-create-submit">Создать канал</button>
          </form>
          <p class="status" id="channel-create-status" hidden></p>
          <p class="hint">Создавать каналы могут владельцы и администраторы комнаты.</p>
        </div>
        <ul class="channels" id="channels-list"></ul>
        </section>

        <section aria-labelledby="channel-heading" id="channel-section" hidden>
          <div class="inline" style="justify-content: space-between; align-items: flex-start; flex-wrap: wrap;">
            <div>
              <h2 id="channel-heading">Выбранный канал</h2>
              <p class="hint" id="channel-hint"></p>
            </div>
            <div class="pill" id="channel-type-pill">—</div>
          </div>

          <div id="text-chat" hidden>
          <div class="status" id="chat-status">Нет активного соединения</div>
          <ul class="messages" id="chat-history"></ul>
          <form id="chat-form" class="chat-actions">
            <label>
              Сообщение
              <textarea id="chat-input" placeholder="Введите сообщение" disabled></textarea>
            </label>
            <div class="inline">
              <button type="submit" id="chat-send" disabled>Отправить</button>
              <button type="button" id="chat-disconnect" style="background: #f8fafc; color: #1f2937; border: 1px solid #d0d7de;" disabled>
                Отключиться
              </button>
            </div>
          </form>
        </div>

        <div id="voice-chat" hidden>
          <div class="status" id="voice-status">Отключено</div>
          <div class="voice-controls">
            <label>
              Микрофон
              <select id="microphone-select"></select>
            </label>
            <div class="inline">
              <button type="button" id="voice-connect">Подключиться</button>
              <button type="button" id="voice-disconnect" style="background: #f8fafc; color: #1f2937; border: 1px solid #d0d7de;" disabled>
                Отключиться
              </button>
              <button type="button" id="voice-start" disabled>Начать звонок</button>
            </div>
            <audio id="remote-audio" controls autoplay></audio>
          </div>
        </div>
        </section>
      </div>
    </main>

    <script>
      const storageKeys = {
        apiBase: "charge.apiBase",
        token: "charge.token",
        room: "charge.lastRoom",
      };

      const state = {
        apiBase: localStorage.getItem(storageKeys.apiBase) || "http://localhost:8000",
        token: localStorage.getItem(storageKeys.token) || null,
        currentRoom: null,
        currentChannel: null,
        chatSocket: null,
        voice: {
          ws: null,
          pc: null,
          localStream: null,
          remoteStream: new MediaStream(),
          joined: false,
          localUser: null,
          selectedDeviceId: null,
        },
      };

      const screens = {
        auth: document.getElementById("screen-auth"),
        workspace: document.getElementById("screen-workspace"),
      };
      const logoutButton = document.getElementById("logout-button");

      const apiForm = document.getElementById("api-form");
      const apiBaseInput = document.getElementById("api-base");
      const authStatus = document.getElementById("auth-status");
      const registerForm = document.getElementById("register-form");
      const registerStatus = document.getElementById("register-status");
      const loginForm = document.getElementById("login-form");
      const loginStatus = document.getElementById("login-status");
      const roomForm = document.getElementById("room-form");
      const roomSlugInput = document.getElementById("room-slug");
      const clearRoomBtn = document.getElementById("clear-room");
      const roomSummary = document.getElementById("room-summary");
      const channelManage = document.getElementById("channel-manage");
      const channelCreateForm = document.getElementById("channel-create-form");
      const channelNameInput = document.getElementById("channel-name");
      const channelTypeSelect = document.getElementById("channel-type");
      const channelCreateButton = document.getElementById("channel-create-submit");
      const channelCreateStatus = document.getElementById("channel-create-status");
      const channelsList = document.getElementById("channels-list");
      const channelSection = document.getElementById("channel-section");
      const channelHint = document.getElementById("channel-hint");
      const channelTypePill = document.getElementById("channel-type-pill");
      const textChat = document.getElementById("text-chat");
      const chatStatus = document.getElementById("chat-status");
      const chatHistory = document.getElementById("chat-history");
      const chatForm = document.getElementById("chat-form");
      const chatInput = document.getElementById("chat-input");
      const chatSend = document.getElementById("chat-send");
      const chatDisconnect = document.getElementById("chat-disconnect");
      const voiceChat = document.getElementById("voice-chat");
      const voiceStatus = document.getElementById("voice-status");
      const micSelect = document.getElementById("microphone-select");
      const voiceConnect = document.getElementById("voice-connect");
      const voiceDisconnect = document.getElementById("voice-disconnect");
      const voiceStart = document.getElementById("voice-start");
      const remoteAudio = document.getElementById("remote-audio");

      apiBaseInput.value = state.apiBase;

      function setStatus(element, message, type = "") {
        if (!element) return;
        element.textContent = message;
        element.hidden = false;
        element.classList.remove("error", "success");
        if (type) {
          element.classList.add(type);
        }
      }

      function clearStatus(element) {
        if (!element) return;
        element.textContent = "";
        element.hidden = true;
        element.classList.remove("error", "success");
      }

      function showScreen(name) {
        Object.entries(screens).forEach(([key, element]) => {
          if (!element) return;
          element.hidden = key !== name;
        });
      }

      function toggleChannelManage(visible) {
        if (channelManage) {
          channelManage.hidden = !visible;
        }
        [channelNameInput, channelTypeSelect, channelCreateButton].forEach((element) => {
          if (element) {
            element.disabled = !visible;
          }
        });
        if (!visible) {
          if (channelCreateForm) {
            channelCreateForm.reset();
          }
          clearStatus(channelCreateStatus);
        }
      }

      function resolveApiUrl(path) {
        const base = state.apiBase.replace(/\/$/, "");
        return `${base}${path}`;
      }

      function resolveWsUrl(path) {
        const baseUrl = new URL(state.apiBase);
        const protocol = baseUrl.protocol === "https:" ? "wss:" : "ws:";
        return `${protocol}//${baseUrl.host}${path}`;
      }

      async function apiFetch(path, options = {}) {
        const headers = new Headers(options.headers || {});
        headers.set("Content-Type", "application/json");
        if (state.token) {
          headers.set("Authorization", `Bearer ${state.token}`);
        }
        const response = await fetch(resolveApiUrl(path), {
          ...options,
          headers,
        });
        if (!response.ok) {
          let detail = `${response.status} ${response.statusText}`;
          try {
            const data = await response.json();
            if (data && data.detail) {
              detail = Array.isArray(data.detail)
                ? data.detail.map((item) => item.msg || item).join(", ")
                : data.detail;
            }
          } catch (_) {
            // ignore JSON parsing errors
          }
          throw new Error(detail);
        }
        if (response.status === 204) {
          return null;
        }
        return response.json();
      }

      function updateAuthStatus() {
        if (state.token) {
          authStatus.textContent = "Токен сохранён";
          authStatus.classList.remove("error");
          authStatus.classList.add("success");
          showScreen("workspace");
        } else {
          authStatus.textContent = "Не авторизовано";
          authStatus.classList.remove("error");
          authStatus.classList.remove("success");
          showScreen("auth");
        }
      }

      function formatDate(value) {
        const date = new Date(value);
        return `${date.toLocaleDateString()} ${date.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })}`;
      }

      function updateRoomSummary() {
        if (!state.currentRoom) return;
        const channelCount = Array.isArray(state.currentRoom.channels)
          ? state.currentRoom.channels.length
          : 0;
        roomSummary.hidden = false;
        roomSummary.textContent = `${state.currentRoom.title} (${state.currentRoom.slug}) — ${channelCount} каналов`;
      }

      function renderChannels(room) {
        channelsList.innerHTML = "";
        if (!room.channels || !room.channels.length) {
          const empty = document.createElement("li");
          empty.textContent = "В комнате нет каналов";
          empty.className = "status";
          channelsList.appendChild(empty);
          return;
        }

        room.channels
          .slice()
          .sort((a, b) => a.letter.localeCompare(b.letter))
          .forEach((channel) => {
            const item = document.createElement("li");
            item.dataset.channelId = channel.id;
            item.dataset.channelLetter = channel.letter;
            item.dataset.channelType = channel.type;
            item.className = "channel";

            const info = document.createElement("div");
            info.className = "channel-info";

            const title = document.createElement("span");
            title.innerHTML = `<span class="channel-letter">${channel.letter}</span> ${channel.name}`;

            const type = document.createElement("span");
            type.className = "channel-type";
            type.textContent = channel.type === "text" ? "Текстовый канал" : "Голосовой канал";

            info.appendChild(title);
            info.appendChild(type);

            const badge = document.createElement("span");
            badge.className = "pill";
            badge.textContent = channel.type === "text" ? "Text" : "Voice";

            item.append(info, badge);

            item.addEventListener("click", () => {
              selectChannel(channel.letter);
            });

            channelsList.appendChild(item);
          });

        updateChannelActiveState();
      }

      if (channelCreateForm) {
        channelCreateForm.addEventListener("submit", async (event) => {
          event.preventDefault();
          if (!state.currentRoom) {
            setStatus(channelCreateStatus, "Сначала загрузите комнату", "error");
            return;
          }

          clearStatus(channelCreateStatus);
          const name = channelNameInput.value.trim();
          const type = channelTypeSelect.value === "voice" ? "voice" : "text";

          if (!name) {
            setStatus(channelCreateStatus, "Введите название канала", "error");
            channelNameInput.focus();
            return;
          }

          setStatus(channelCreateStatus, "Создание…");
          channelCreateButton.disabled = true;

          try {
            const channel = await apiFetch(
              `/api/rooms/${encodeURIComponent(state.currentRoom.slug)}/channels`,
              {
                method: "POST",
                body: JSON.stringify({ name, type }),
              },
            );

            const channels = Array.isArray(state.currentRoom.channels)
              ? state.currentRoom.channels.filter((item) => item.id !== channel.id)
              : [];
            channels.push(channel);
            state.currentRoom.channels = channels;

            updateRoomSummary();
            renderChannels(state.currentRoom);
            setStatus(
              channelCreateStatus,
              `Канал ${channel.letter} создан`,
              "success",
            );
            channelCreateForm.reset();
            channelNameInput.focus();
          } catch (error) {
            setStatus(channelCreateStatus, error.message, "error");
          } finally {
            channelCreateButton.disabled = false;
          }
        });
      }

      function updateChannelActiveState() {
        Array.from(channelsList.children).forEach((element) => {
          if (!(element instanceof HTMLElement)) return;
          if (element.dataset.channelLetter) {
            element.classList.toggle(
              "active",
              state.currentChannel && element.dataset.channelLetter === state.currentChannel.letter
            );
          }
        });
      }

      function clearChannelSelection() {
        channelSection.hidden = true;
        textChat.hidden = true;
        voiceChat.hidden = true;
        channelHint.textContent = "";
        channelTypePill.textContent = "—";
        state.currentChannel = null;
        disconnectChat();
        disconnectVoice();
        const params = new URLSearchParams(window.location.search);
        if (state.currentRoom) {
          params.set("room", state.currentRoom.slug);
        } else {
          params.delete("room");
        }
        params.delete("channel");
        const query = params.toString();
        history.replaceState(null, "", `${window.location.pathname}${query ? `?${query}` : ""}`);
        updateChannelActiveState();
      }

      function selectChannel(letter) {
        if (!state.currentRoom) return;
        const normalizedLetter = letter.toUpperCase();
        if (state.currentChannel && state.currentChannel.letter === normalizedLetter) {
          clearChannelSelection();
          return;
        }
        const channel = state.currentRoom.channels.find((item) => item.letter === normalizedLetter);
        if (!channel) return;

        state.currentChannel = channel;
        channelSection.hidden = false;
        channelHint.textContent = `Канал ${channel.name} (${channel.letter}) комнаты ${state.currentRoom.title}`;
        channelTypePill.textContent = channel.type === "text" ? "Text" : "Voice";

        const params = new URLSearchParams(window.location.search);
        params.set("room", state.currentRoom.slug);
        params.set("channel", channel.letter);
        history.replaceState(null, "", `${window.location.pathname}?${params.toString()}`);

        updateChannelActiveState();
        if (channel.type === "text") {
          voiceChat.hidden = true;
          setupTextChannel(channel);
        } else {
          textChat.hidden = true;
          setupVoiceChannel(channel);
        }
      }

      function setupTextChannel(channel) {
        disconnectChat();
        disconnectVoice();
        textChat.hidden = false;
        chatHistory.innerHTML = "";
        chatInput.disabled = true;
        chatSend.disabled = true;
        chatDisconnect.disabled = true;
        setStatus(chatStatus, "Подключение к WebSocket…");
        connectChat(channel.id);
      }

      function connectChat(channelId) {
        disconnectChat();
        if (!state.token) {
          setStatus(chatStatus, "Необходимо войти", "error");
          return;
        }

        const wsUrl = new URL(resolveWsUrl(`/ws/text/${channelId}`));
        wsUrl.searchParams.set("token", state.token);
        const socket = new WebSocket(wsUrl.toString());
        state.chatSocket = socket;

        socket.addEventListener("open", () => {
          setStatus(chatStatus, "Соединение установлено", "success");
          chatInput.disabled = false;
          chatSend.disabled = false;
          chatDisconnect.disabled = false;
          chatInput.focus();
        });

        socket.addEventListener("close", () => {
          setStatus(chatStatus, "Соединение закрыто");
          chatInput.disabled = true;
          chatSend.disabled = true;
          chatDisconnect.disabled = true;
        });

        socket.addEventListener("error", () => {
          setStatus(chatStatus, "Ошибка WebSocket", "error");
        });

        socket.addEventListener("message", (event) => {
          try {
            const payload = JSON.parse(event.data);
            handleChatPayload(payload);
          } catch (error) {
            console.error("Invalid message", error);
          }
        });
      }

      function handleChatPayload(payload) {
        if (!payload || typeof payload !== "object") return;
        if (payload.type === "history" && Array.isArray(payload.messages)) {
          chatHistory.innerHTML = "";
          payload.messages.forEach((message) => appendChatMessage(message));
          chatHistory.scrollTop = chatHistory.scrollHeight;
        }
        if (payload.type === "message" && payload.message) {
          appendChatMessage(payload.message);
        }
        if (payload.type === "error" && payload.detail) {
          setStatus(chatStatus, payload.detail, "error");
        }
      }

      function appendChatMessage(message) {
        const item = document.createElement("li");
        const meta = document.createElement("div");
        meta.className = "message-meta";
        const author = document.createElement("span");
        author.textContent = message.author_id ? `#${message.author_id}` : "System";
        const time = document.createElement("span");
        time.textContent = formatDate(message.created_at);
        meta.append(author, time);

        const content = document.createElement("div");
        content.className = "message-content";
        content.textContent = message.content;

        item.append(meta, content);
        chatHistory.appendChild(item);
        chatHistory.scrollTop = chatHistory.scrollHeight;
      }

      function disconnectChat() {
        if (state.chatSocket) {
          state.chatSocket.close();
          state.chatSocket = null;
        }
      }

      chatForm.addEventListener("submit", (event) => {
        event.preventDefault();
        if (!state.chatSocket || state.chatSocket.readyState !== WebSocket.OPEN) return;
        const content = chatInput.value.trim();
        if (!content) return;
        state.chatSocket.send(JSON.stringify({ content }));
        chatInput.value = "";
        chatInput.focus();
      });

      chatDisconnect.addEventListener("click", () => {
        disconnectChat();
      });

      function setupVoiceChannel(channel) {
        disconnectChat();
        disconnectVoice();
        voiceChat.hidden = false;
        voiceStatus.textContent = "Отключено";
        voiceStatus.classList.remove("error", "success");
        voiceStart.disabled = true;
        voiceDisconnect.disabled = true;
        voiceConnect.disabled = false;
      }

      function cleanupVoicePeerConnection() {
        const { voice } = state;
        if (voice.pc) {
          voice.pc.ontrack = null;
          voice.pc.onicecandidate = null;
          voice.pc.onconnectionstatechange = null;
          voice.pc.close();
          voice.pc = null;
        }
      }

      function disconnectVoice(silent = false) {
        const { voice } = state;
        const activeSocket = voice.ws;
        if (activeSocket) {
          if (!silent) {
            sendVoiceBye(activeSocket);
          }
          voice.ws = null;
          try {
            activeSocket.close();
          } catch (error) {
            console.error("Error closing voice socket", error);
          }
        }
        voice.joined = false;
        voice.localUser = null;
        cleanupVoicePeerConnection();
        if (voice.localStream) {
          voice.localStream.getTracks().forEach((track) => track.stop());
          voice.localStream = null;
        }
        voice.remoteStream = new MediaStream();
        remoteAudio.srcObject = null;
        voiceStatus.textContent = "Отключено";
        voiceStatus.classList.remove("success", "error");
        voiceStart.disabled = true;
        voiceDisconnect.disabled = true;
        voiceConnect.disabled = false;
      }

      function ensurePeerConnection() {
        const { voice } = state;
        if (voice.pc) return voice.pc;
        const pc = new RTCPeerConnection({
          iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
        });
        pc.onicecandidate = (event) => {
          if (event.candidate && voice.ws && voice.ws.readyState === WebSocket.OPEN) {
            voice.ws.send(
              JSON.stringify({
                type: "candidate",
                candidate: event.candidate,
              })
            );
          }
        };
        pc.ontrack = (event) => {
          if (!remoteAudio.srcObject) {
            remoteAudio.srcObject = voice.remoteStream;
          }
          event.streams[0].getTracks().forEach((track) => {
            voice.remoteStream.addTrack(track);
          });
        };
        pc.onconnectionstatechange = () => {
          if (pc.connectionState === "disconnected" || pc.connectionState === "failed") {
            setStatus(voiceStatus, "Потеряно соединение", "error");
          }
        };
        if (!remoteAudio.srcObject) {
          remoteAudio.srcObject = voice.remoteStream;
        }
        voice.pc = pc;
        return pc;
      }

      async function ensureLocalStream() {
        const { voice } = state;
        if (voice.localStream) {
          return voice.localStream;
        }
        const constraints = {
          audio: voice.selectedDeviceId ? { deviceId: { exact: voice.selectedDeviceId } } : true,
        };
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        voice.localStream = stream;
        const pc = ensurePeerConnection();
        stream.getTracks().forEach((track) => {
          const sender = pc.getSenders().find((s) => s.track && s.track.kind === track.kind);
          if (sender) {
            sender.replaceTrack(track);
          } else {
            pc.addTrack(track, stream);
          }
        });
        return stream;
      }

      async function connectVoice() {
        if (!state.currentRoom) {
          setStatus(voiceStatus, "Сначала выберите комнату", "error");
          return;
        }
        if (!state.token) {
          setStatus(voiceStatus, "Необходимо войти", "error");
          return;
        }
        try {
          await ensureLocalStream();
        } catch (error) {
          setStatus(voiceStatus, `Нет доступа к микрофону: ${error.message}`, "error");
          return;
        }

        const wsUrl = new URL(resolveWsUrl(`/ws/signal/${state.currentRoom.slug}`));
        wsUrl.searchParams.set("token", state.token);
        const socket = new WebSocket(wsUrl.toString());
        state.voice.ws = socket;
        const pc = ensurePeerConnection();

        socket.onopen = () => {
          setStatus(voiceStatus, "Сигнальный канал подключен", "success");
          voiceConnect.disabled = true;
          voiceDisconnect.disabled = false;
          voiceStart.disabled = false;
        };

        socket.onclose = () => {
          disconnectVoice(true);
        };

        socket.onerror = () => {
          setStatus(voiceStatus, "Ошибка WebSocket", "error");
        };

        socket.onmessage = async (event) => {
          let message;
          try {
            message = JSON.parse(event.data);
          } catch (error) {
            console.error("Invalid signalling message", event.data);
            return;
          }

          if (message.type === "error") {
            setStatus(voiceStatus, message.detail || "Ошибка", "error");
            return;
          }

          if (message.type === "system") {
            if (message.event === "welcome") {
              state.voice.joined = true;
              state.voice.localUser = message.user;
              setStatus(voiceStatus, "Подключено, ожидаем звонок", "success");
            }
            if (message.event === "peer-joined") {
              setStatus(voiceStatus, `${message.user.displayName || message.user.id} подключился`, "success");
            }
            if (message.event === "peer-left") {
              setStatus(voiceStatus, `${message.user.displayName || message.user.id} отключился`);
            }
            return;
          }

          if (!state.voice.joined) {
            console.warn("Игнорируем сигнал до приветствия");
            return;
          }

          switch (message.type) {
            case "offer":
              if (!message.description) return;
              await pc.setRemoteDescription(new RTCSessionDescription(message.description));
              const answer = await pc.createAnswer();
              await pc.setLocalDescription(answer);
              socket.send(
                JSON.stringify({
                  type: "answer",
                  description: pc.localDescription,
                })
              );
              break;
            case "answer":
              if (!message.description) return;
              await pc.setRemoteDescription(new RTCSessionDescription(message.description));
              break;
            case "candidate":
              if (message.candidate) {
                try {
                  await pc.addIceCandidate(new RTCIceCandidate(message.candidate));
                } catch (error) {
                  console.error("Failed to add ICE candidate", error);
                }
              }
              break;
            case "bye":
              setStatus(voiceStatus, "Удалённый участник завершил звонок");
              cleanupVoicePeerConnection();
              state.voice.remoteStream = new MediaStream();
              remoteAudio.srcObject = null;
              ensurePeerConnection();
              if (state.voice.localStream) {
                state.voice.localStream.getTracks().forEach((track) => {
                  const sender = state.voice.pc.getSenders().find((s) => s.track && s.track.kind === track.kind);
                  if (sender) {
                    sender.replaceTrack(track);
                  } else {
                    state.voice.pc.addTrack(track, state.voice.localStream);
                  }
                });
              }
              break;
            default:
              console.warn("Неизвестный сигнал", message);
          }
        };
      }

      async function startVoiceCall() {
        const { voice } = state;
        if (!voice.ws || voice.ws.readyState !== WebSocket.OPEN) return;
        const pc = ensurePeerConnection();
        if (!voice.localStream) {
          try {
            await ensureLocalStream();
          } catch (error) {
            setStatus(voiceStatus, error.message, "error");
            return;
          }
        }

        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        voice.ws.send(
          JSON.stringify({
            type: "offer",
            description: pc.localDescription,
          })
        );
        setStatus(voiceStatus, "Отправлен offer", "success");
      }

      function sendVoiceBye(socket = state.voice.ws) {
        if (socket && socket.readyState === WebSocket.OPEN) {
          socket.send(JSON.stringify({ type: "bye" }));
        }
      }

      voiceConnect.addEventListener("click", () => {
        connectVoice();
      });

      voiceDisconnect.addEventListener("click", () => {
        disconnectVoice();
      });

      voiceStart.addEventListener("click", () => {
        startVoiceCall();
      });

      micSelect.addEventListener("change", async () => {
        state.voice.selectedDeviceId = micSelect.value || null;
        if (state.voice.localStream) {
          state.voice.localStream.getTracks().forEach((track) => track.stop());
          state.voice.localStream = null;
        }
        if (state.voice.ws) {
          try {
            await ensureLocalStream();
          } catch (error) {
            setStatus(voiceStatus, error.message, "error");
          }
        }
      });

      async function populateMicrophones() {
        if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
          micSelect.innerHTML = `<option value="">Не поддерживается браузером</option>`;
          micSelect.disabled = true;
          return;
        }
        try {
          const devices = await navigator.mediaDevices.enumerateDevices();
          const audioInputs = devices.filter((device) => device.kind === "audioinput");
          micSelect.innerHTML = "";
          if (!audioInputs.length) {
            micSelect.innerHTML = `<option value="">Микрофоны не найдены</option>`;
            micSelect.disabled = true;
            state.voice.selectedDeviceId = null;
          } else {
            const previous = state.voice.selectedDeviceId;
            let applied = false;
            audioInputs.forEach((device, index) => {
              const option = document.createElement("option");
              option.value = device.deviceId;
              option.textContent = device.label || `Микрофон ${index + 1}`;
              if (previous && device.deviceId === previous) {
                option.selected = true;
                applied = true;
              }
              micSelect.appendChild(option);
            });
            micSelect.disabled = false;
            if (!applied) {
              state.voice.selectedDeviceId = audioInputs[0]?.deviceId || null;
              if (state.voice.selectedDeviceId) {
                micSelect.value = state.voice.selectedDeviceId;
              }
            }
          }
        } catch (error) {
          micSelect.innerHTML = `<option value="">${error.message}</option>`;
          micSelect.disabled = true;
        }
      }

      async function loadRoom(slug) {
        toggleChannelManage(false);
        if (!state.token) {
          setStatus(roomSummary, "Необходимо войти", "error");
          roomSummary.hidden = false;
          return;
        }
        clearStatus(roomSummary);
        setStatus(roomSummary, "Загрузка…");
        try {
          const room = await apiFetch(`/api/rooms/${encodeURIComponent(slug)}`);
          state.currentRoom = room;
          clearChannelSelection();
          localStorage.setItem(storageKeys.room, slug);
          updateRoomSummary();
          renderChannels(room);
          const params = new URLSearchParams(window.location.search);
          params.set("room", slug);
          if (state.currentChannel) {
            params.set("channel", state.currentChannel.letter);
          }
          history.replaceState(null, "", `${window.location.pathname}?${params.toString()}`);
          toggleChannelManage(true);
        } catch (error) {
          setStatus(roomSummary, `Ошибка загрузки: ${error.message}`, "error");
          state.currentRoom = null;
          channelsList.innerHTML = "";
          clearChannelSelection();
          toggleChannelManage(false);
        }
      }

      apiForm.addEventListener("submit", (event) => {
        event.preventDefault();
        const value = apiBaseInput.value.trim();
        if (!value) return;
        state.apiBase = value;
        localStorage.setItem(storageKeys.apiBase, value);
        setStatus(authStatus, "URL обновлён", "success");
      });

      registerForm.addEventListener("submit", async (event) => {
        event.preventDefault();
        clearStatus(registerStatus);
        const formData = new FormData(registerForm);
        const payload = {
          login: formData.get("login"),
          display_name: formData.get("display_name"),
          password: formData.get("password"),
        };
        try {
          await apiFetch("/api/auth/register", {
            method: "POST",
            body: JSON.stringify(payload),
          });
          setStatus(registerStatus, "Пользователь создан", "success");
          registerForm.reset();
        } catch (error) {
          setStatus(registerStatus, error.message, "error");
        }
      });

      loginForm.addEventListener("submit", async (event) => {
        event.preventDefault();
        clearStatus(loginStatus);
        const formData = new FormData(loginForm);
        const payload = {
          login: formData.get("login"),
          password: formData.get("password"),
        };
        try {
          const token = await apiFetch("/api/auth/login", {
            method: "POST",
            body: JSON.stringify(payload),
          });
          state.token = token.access_token;
          localStorage.setItem(storageKeys.token, state.token);
          updateAuthStatus();
          setStatus(loginStatus, "Успешный вход", "success");
          if (screens.workspace) {
            screens.workspace.scrollIntoView({ behavior: "smooth", block: "start" });
          }
          if (roomSlugInput) {
            roomSlugInput.focus();
          }
          const slug = roomSlugInput.value.trim();
          if (slug) {
            loadRoom(slug);
          }
        } catch (error) {
          setStatus(loginStatus, error.message, "error");
        }
      });

      roomForm.addEventListener("submit", (event) => {
        event.preventDefault();
        const slug = roomSlugInput.value.trim();
        if (!slug) return;
        loadRoom(slug);
      });

      clearRoomBtn.addEventListener("click", () => {
        state.currentRoom = null;
        channelsList.innerHTML = "";
        roomSummary.hidden = true;
        roomSlugInput.value = "";
        toggleChannelManage(false);
        clearChannelSelection();
        const params = new URLSearchParams(window.location.search);
        params.delete("room");
        params.delete("channel");
        history.replaceState(null, "", `${window.location.pathname}${params.size ? `?${params.toString()}` : ""}`);
      });

      if (logoutButton) {
        logoutButton.addEventListener("click", () => {
          state.token = null;
          localStorage.removeItem(storageKeys.token);
          disconnectChat();
          disconnectVoice();
          state.currentRoom = null;
          state.currentChannel = null;
          localStorage.removeItem(storageKeys.room);
          channelsList.innerHTML = "";
          channelSection.hidden = true;
          roomSummary.hidden = true;
          roomSlugInput.value = "";
          toggleChannelManage(false);
          clearChannelSelection();
          clearStatus(channelCreateStatus);
          clearStatus(roomSummary);
          updateAuthStatus();
          loginForm.reset();
          setStatus(loginStatus, "Сессия завершена", "success");
        });
      }

      function restoreFromQuery() {
        const params = new URLSearchParams(window.location.search);
        const room = params.get("room") || localStorage.getItem(storageKeys.room);
        const channelLetter = params.get("channel");
        if (room) {
          roomSlugInput.value = room;
          loadRoom(room).then(() => {
            if (channelLetter) {
              selectChannel(channelLetter);
            }
          });
        }
      }

      updateAuthStatus();
      toggleChannelManage(false);
      populateMicrophones();
      if (navigator.mediaDevices) {
        if (typeof navigator.mediaDevices.addEventListener === "function") {
          navigator.mediaDevices.addEventListener("devicechange", populateMicrophones);
        } else if ("ondevicechange" in navigator.mediaDevices) {
          navigator.mediaDevices.ondevicechange = populateMicrophones;
        }
      }
      restoreFromQuery();

      window.addEventListener("beforeunload", () => {
        disconnectChat();
        disconnectVoice();
      });
    </script>
  </body>
</html>
